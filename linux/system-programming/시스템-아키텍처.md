# 폰노이만 아키텍처

## CPU의 역할

- 0과 1로 구성된 명령어를 하나씩 수행하는 장치
- CPU에는 명령어들을 저장할 넉넉한 공간이 없기 때문에 Disk에 저장한다.
- Disk에서 CPU로 명령어가 하나씩 전달되어 수행한다.
- 이런 원리로 차례대로 모두 수행된다.

> 이런 방식으로는 CPU의 효율이 너무 떨어진다. 이 문제의 해결 방안으로 폰노이만이 메모리를 제시했다.

## 메모리

- 빠른 성능, 저장장치 처럼 저장하는 기능을 갖지만 전원을 끄면 모두 소멸되는 장치
- 명령어들을 대신 전달해주는 역할을 한다.

### Load 작업

- 저장장치에 저장된 0과 1 장치가 메모리에 한꺼번에 복사된다.
- 이때는 시간이 제법 걸린다. (프로그램 전체를 모두 불러와야 하기 때문)
- 이 동작을 적재(Load) 라고하며, 흔히 Loading 이라고 부르는 말이 이러한 뜻이다.

이제 Disk 대신 메모리가 CPU에게 전달한다.
- 이전에 비하면 엄청 빠르다.
- CPU와 메모리 사이에 데이터를 주고 받는다.
- 메모리가 빠르다고는 하나 여전히 CPU보다는 느리다. 하지만 HDD에 비하면 엄청 빠르다.

이 원리를 폰노이만 아키텍처 라고 한다.
- 컴퓨터는 1941년부터 70년 이상 이 구조를 채태갛고 있다.
- 이 구조에서 약간 변형한 "하버드아키텍처" 가 있지만, 기본 골격은 폰노이만 아키텍처이다.

# D램과 S램

메모리는 여전히 느리다.
메모리가 명령어를 전달하는 동안 속도가 더 빠른 CPU는 기다리는 시간이 발생한다.
- 대기 시간동안 아무것도 하지 않는다.

## S램

CPU 안에 더 빠른 메로리를 내장하면 된다. => S램
- 저장공간은 작지만, 기존에 메모리보다 더 빠른 성능을 내는 메모리
- D램에서 S램으로 여러줄의 명령어를 한꺼번에 전달한다.
- 모든 명령어를 다 수행했을 경우, 다음 명령어 덩어리들을 D램에게 전달 받는다.

이 S램을 Cache 메모리라고 한다.
- Cache 메모리에 Hit / Miss 전략을 통해 효율성을 더 높이는 방법도 존재한다.

S램, D램 : HW 구조적으로 static / dynamic 용어로 만들어진 이름
S램은 `Cache` 메모리 라고도 하며, D램은 `Main` 메모리 라고 불린다.

# 프로그램과 프로세스

## 프로그램

- CPU의 2진수 명령어들의 조합
- 프로그램을 실행하면 메모리에 적재된다. (로딩된다)

## 프로세스

- 실행된 프로그램을 뜻하는 용어

프로그램 : CPU의 2진수 명령어의 집합
프로세서 : 프로그램을 실행하는 칩셋 (HW)
프로세스 : 실행된 프로그램

# 메모리 구조

## 메모리의 역할

1. 0과 1로 된 CPU 명령어를 저장하는 역할
2. 변수가 만들어지는 공간

메모리 공간을 나누어서 활용한다.

프로그램으로 나뉜 각 프로세스는 세부적으로 또 나뉜 공간을 갖는다.
(소스코드 공간, 변수들이 만들어질 공간)

> 프로세스 : 프로그램을 실행한 상태
> 스레드 : 프로세스 내에서 더 작은 단위로 실행되는 "흐름"
>
> 하나의 프로세스는 기본적으로 하나의 스레드를 갖고 있다.
> 멀티 프로세스 : 여러 CPU로 프로세스가 동작하는 것
> 멀티 스레드 : 프로세스 내 여러 개의 스레드가 동시 동작하는 상황
> 멀티 태스킹 : 여러 프로세스가 동작하는 것

## [암기] Process 구성

하나의 Process 는
text / data / bss / stack / heap 세그먼트로 구성

- .text
  - 코드 영역
- .data : 초기화된 전역변수
  - 하드코딩 데이터
- .bss : 초기화 안된 전역변수
  - 초기값이 없bss
- .heap / .stack
  - .stack : 지역변수
  - .heap : malloc 으로 만든 변수들

int t; : .bss
int g = 32; : .data
int q = 31; : stack
int *p = heap

변수가 어느 세그먼트에 포함될지 잘 생각해보자.

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int t;
int g = 32;

int main()
{
    int q = 31;
    int *p = (int*) malloc(sizeof(4));
    while(1) {
        printf("DATA(%d) = 0x%X\n", g, &g);
        printf("BSS = 0x%X\n", &t);
        printf("HEAP = 0x%X\n", p);
        printf("STACK = 0x%X\n", &q);
        printf("=========\n");
        sleep(1);
        g++;
    }
    free(p);
    return 0;
}

```

## 정리

> 각각의 프로세스는 독립적인 메모리 공간을 갖고 있다.

# 다중 Process (동시 작업이 필요한 경우)

한 프로세스 안에서 하나의 캐릭터가 뛰어 놀 수 있도록 개발하는 것은 쉽다.

한 프로세스 안에서 캐릭터들이 동시에 움직이도록 코딩하는 것이 어렵다.
- 이럴 때 사용하는 것이 Thread 이다.

> 운영체제가 API로 지원해 주어야만 한다.

`Thread`를 위한 `POSIX API` 가 존재하여, 이 `Thread POSIX API` 만 사용할 줄 알면, 쉽게 동시작업 프로그래밍이 가능하다.

## 정리

임베디드 제품 개발 시
- 여러 프로세스를 동시에 동작시키는 멀티태스킹을 구현해야 할 때
- 한 프로세스 내 쓰레드 프로그래밍이 필요할 때

위와 같은 경우에 Firmware (직접개발) 보다는
POSIX API 가 지원하는 RTOS 또는 Linux 급의 OS를 임베디드 제품에 설치 후, 임베디드 개발을 한다. (펌웨어에서도 가능한 경우다 있는데, 이건 고인물이다.)

> OS 를 임베디드 제품에 설치하는 것을 `포팅` 이라고 하는데, 이는 매우 어려운 작업이다. 기기의 하드, 메모리 등에 맞게 각각의 코드들을 수정해줘야 한다.

### Quiz

프로세스끼리는 독립된 메모리 공간을 갖는다. (O, X)

> 정답은 O

따라서 변수값들을 서로 공유할 수 없다.
`IPC` 를 이용하면 가능

# 총정리

시스템 아키텍처
- 폰노이만이 고안
- CPU에 비해 HDD의 성능이 낮으니
- 중간에 메모리를 두자.

HDD ->(Load) Main Memory -> Cache Memory -> CPU

가격 : s램 > d램

---

프로세스 : 프로그램을 실행 (메모리에 로드) 한 결과
프로그램 : 이진수로 된 명령어의 집합
프로세서 : H/W

---

메모리는 프로세스들을 위한 공간을 마련해 둠
-> 각각의 프로세스는 독자적인 공간을 가진다.

프로세스 안에는 분류가 되어 있다.
.text : 코드
.data : 초기화 된 전역변수
.bss : 초기화 안 된 전역변수
.heap
.stack
-> 코드 짤 때 고민해야 한다. (상급자, 고인물이 하는 일)

---

프로세스 : 프로그램이 실행한 결과
스레드 : 프로세스 내 작업을 수행하는 단위

-> 프로세스에는 기본적으로 하나의 스레드가 동작한다.
(펌웨어 시장은 1개의 프로세스가 동작한다.)

---

동시 동작을 위해서는 OS의 도움이 필요하고 (-> API (POSIX))
POSIX API 안에 있는 Thread를 이용하면 멀티태스킹이 가능한 프로그램을 제작할 수 있다.

> Thread 부터 오프라인